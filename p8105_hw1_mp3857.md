HW 1 P8105
================
Michelle Poimboeuf
2020-09-17

This is my solution to HW1

``` r
library(tidyverse)
```

    ## ── Attaching packages ──────────────────────────────────────────── tidyverse 1.3.0 ──

    ## ✓ ggplot2 3.3.2     ✓ purrr   0.3.4
    ## ✓ tibble  3.0.3     ✓ dplyr   1.0.2
    ## ✓ tidyr   1.1.2     ✓ stringr 1.4.0
    ## ✓ readr   1.3.1     ✓ forcats 0.5.0

    ## ── Conflicts ─────────────────────────────────────────────── tidyverse_conflicts() ──
    ## x dplyr::filter() masks stats::filter()
    ## x dplyr::lag()    masks stats::lag()

## Problem 1

Create a dataframe with the specified elements.

``` r
prob1_df = 
tibble(
  samp = rnorm(10),
  samp_gt_0 = samp > 0, 
  char_vec = c("a", "b", "c", "d", "e", "f", "g", "h", "i", "j"),
  factor_vec = factor(c("low", "low", "low", "mod", "mod", "mod","mod", "high", "high", "high"))
)
```

Take the mean of each variable in my data frame.

``` r
mean(pull(prob1_df, samp))
```

    ## [1] 0.5051087

``` r
mean(pull(prob1_df, samp_gt_0))
```

    ## [1] 0.7

``` r
mean(pull(prob1_df, char_vec))
```

    ## Warning in mean.default(pull(prob1_df, char_vec)): argument is not numeric or
    ## logical: returning NA

    ## [1] NA

``` r
mean(pull(prob1_df, factor_vec))
```

    ## Warning in mean.default(pull(prob1_df, factor_vec)): argument is not numeric or
    ## logical: returning NA

    ## [1] NA

I can take the mean of the numeric and logical vectors, but not the
factor or the character vectors. This makes some sense as numbers have
means. It is a bit confusing as to why you would be able to take the
mean of the logical vector, when you wouldn’t be able to take it of the
factor or character vectors. I see that R will code things in a way that
does not necessarily make sense. \<\<\<\<\<\<\< HEAD

``` r
as.numeric(pull(prob1_df, samp))
```

    ##  [1]  0.40659414  1.55439365 -1.47917100 -0.37709918  2.03849136  1.29946298
    ##  [7] -0.03734348  0.88328690  0.45038718  0.31208417

``` r
as.numeric(pull(prob1_df, samp_gt_0))
```

    ##  [1] 1 1 0 0 1 1 0 1 1 1

``` r
as.numeric(pull(prob1_df, char_vec))
```

    ## Warning: NAs introduced by coercion

    ##  [1] NA NA NA NA NA NA NA NA NA NA

``` r
as.numeric(pull(prob1_df, factor_vec))
```

    ##  [1] 2 2 2 3 3 3 3 1 1 1

Above, adding the as.numeric code to the beginning of the chunk
explicitly performs the action that R was performing behind the scenes
in the last code chunk. It shows the steps to coding the vectors as
numeric and helps explain why R thinks it can take the mean of certain
vectors.

Second Code Chunk for Problem 1:

``` r
as.numeric(pull(prob1_df, samp_gt_0))*pull(prob1_df, samp)
```

    ##  [1] 0.4065941 1.5543936 0.0000000 0.0000000 2.0384914 1.2994630 0.0000000
    ##  [8] 0.8832869 0.4503872 0.3120842

``` r
as.factor(pull(prob1_df, samp_gt_0))*pull(prob1_df, samp)
```

    ## Warning in Ops.factor(as.factor(pull(prob1_df, samp_gt_0)), pull(prob1_df, : '*'
    ## not meaningful for factors

    ##  [1] NA NA NA NA NA NA NA NA NA NA

``` r
as.factor(pull(prob1_df, samp_gt_0))*pull(prob1_df, samp)
```

    ## Warning in Ops.factor(as.factor(pull(prob1_df, samp_gt_0)), pull(prob1_df, : '*'
    ## not meaningful for factors

    ##  [1] NA NA NA NA NA NA NA NA NA NA
